{"pageProps":{"postData":{"id":"my-software-design-pattern","contentHtml":"<p>The software design pattern is essential when we start to develop software.\nIt's about how we structure our codes, how we split our codes into components and modules, what framework we are going to use, etc.\nThere are a lot of books that have a lot of great patterns we can follow.\nHowever, as a developer, I believe that every one of us has a pattern for ourselves and we like to use it.</p>\n<p>My design came from many projects and code bases I have worked with.\nFrom codebases for an embedded device to a web service, I have established a common pattern for all of them.</p>\n<h1>The entrypoint should be commands</h1>\n<p>The final executable file or entry point should support multiple commands and options to do all functions of the software.\nFor example, let's say a tool that imports and exports a database, it has simple two main functions.\nIf it was me 4 years ago, I will output two executable files including import and export and I will use this tool as below:</p>\n<pre><code class=\"language-bash\"># use tool_import when I need to import database\ntool_import some_database\n\n# use tool_export when I need to export database\ntool_export some_database\n</code></pre>\n<p>But I'm at present, I will output only an executable file and use it as below:</p>\n<pre><code class=\"language-bash\"># use tool with import command and options\ntool import --database some_database --from ./some_databse.backup\n\n# use tool with export command and options\ntool export --database some_database --to ./some_databse.backup\n</code></pre>\n<p>Good things from the second design are:</p>\n<ul>\n<li>It's easy to add more functions and options (easy to scale).</li>\n<li>It's easy to know what does the tool do (use the help command).</li>\n</ul>\n<h1>Put reusable codes into libraries</h1>\n<p>Many codebases sometime use the same codes and utility functions.\nFor example, convert time formats, read file content, or print logs in our favorite format.\nAnd I put these pieces of code into separate libraries, then export them, so I can easily import them into other codebases.</p>\n<p>The best thing about this design is I can reuse my codes in multiple codebases, prevent duplicated codes, and save time.</p>\n<h1>Split external integrations into services</h1>\n<p>Our software doesn't do everything itself, also integrates with other software as well. I usually write services that do tasks and calls to a specific service.\nFor example, if my software needs a database, I will build up a service that handles all logic and calls to the database service. I usually name it a database service or storage service.\nAnd with every external software like that, I also write another service too.</p>\n<p>This design brings to me some good things:</p>\n<ul>\n<li>It's easy to update or integrate with external services. For example, when we need to update the database library, we just need to update codes in the database service and do tests with it only without retest with the whole codebase.</li>\n<li>It helps me also reuse the codes in multiple codebases.</li>\n</ul>\n<p>Furthermore, I usually design my service with the inheritance.\nWhenever I need to read from or write to the database, I need to request the database service only.\nAnd on behalf of my call, the database service should be able to handle requests to Postgresql, MongoDB, or whatever database I'm using.\nIt makes me easy to scale up whenever I need to integrate with another service.</p>\n<pre><code class=\"language-text\">\n+-----------------+                             +---------------+\n|    Somewhere    |  request to read database   |    Database   |\n|    in my code   | --------------------------> |    service    |\n+-----------------+                             +---------------+\n                                                        |\n                                +---------------+---------------+\n                                |               |               |\n                                |               |               |\n                         +--------------+  +------------+   +------------+\n                         | Easy to      |  | Postgresql |   | MongoDB    |\n                         | add more ... |  |            |   |            |\n                         +--------------+  +------------+   +------------+\n</code></pre>\n<h1>Write main logic in modules</h1>\n<p>I usually split my software logic into multiple modules, every module does a specific function.\nFor example, in an e-commerce API service, I will split logic into basic modules as below:</p>\n<ul>\n<li>API routes, initialize web router and API routing.</li>\n<li>Account, handle all logic related to accounts like create, update, login, ...</li>\n<li>Payment, handle all logic about payment, charges, subscriptions, ...</li>\n</ul>\n<p>In every module, it can call external services or use utility libraries following my design above.</p>\n<p>By split logic into modules, I can:</p>\n<ul>\n<li>Easy to scale my software, when I need to add more functions, I just need to make another module.</li>\n<li>Easy to do tests with software logic in modules one by one.</li>\n</ul>\n<pre><code class=\"language-text\">\n+-----------------+                        +--------------+\n|    Account      |   save account data    |   Database   |\n|    module       | ---------------------> |   service    |\n+-----------------+   |                    +--------------+\n       |              |\n       |              | write logs         +--------------+\n       |              |------------------> |  Logging     |\n+-----------------+                        |  service     |\n|  Validation     |                        +--------------|\n|  library        |\n+-----------------+\n</code></pre>\n<h1>Configurations</h1>\n<p>My favorite config format is <code>.env</code> files, or I just directly export them to environment variables.\nI don't really have many reasons for this, but I think because I usually deploy my code using Docker or cloud services like Heroku.\nSo, environment variables are easy to use with these platforms.</p>\n<h1>Codebase files structure</h1>\n<p>As my design, I structure my codebase folders into four main directories:</p>\n<pre><code class=\"language-text\">\n/\n|--cmd          // contains all export commands, and entry points\n|--lib,         // contains all external libraries, or utility functions\n|--modules,     // contains all external service integration logic\n|--services,    // contains the software logic\n\n</code></pre>\n<p>This pattern is just my personal favorite, of course, I don't use it in every software I built, but it is the most pattern I have ever used. Happy building!</p>","title":"My Software Design Pattern","description":"Let me share with you my favorite pattern and structure I usually use in my codebases.","author":"Eden","date":"Oct 1st, 2021","tag":"Writing"}},"__N_SSG":true}