<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/9dd713fd4ffd7d87.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9dd713fd4ffd7d87.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/_next/static/chunks/main-805fb4f55afd8b07.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e7e2a935ab64e067.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-f60aef3f2a9870a4.js" defer=""></script><script src="/_next/static/Zqp_tgPZRVjTdyHmPCy7k/_buildManifest.js" defer=""></script><script src="/_next/static/Zqp_tgPZRVjTdyHmPCy7k/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="__className_01316c"><div class="mx-auto max-w-2xl px-5"><div class="mt-10 flex justify-between items-center"><a href="/"><p class="text-xl font-bold text-foreground">Eden Garden üçÉ</p></a><div class="flex justify-center"><a class="underline" href="/">Home</a><a class="ml-5 underline" href="/writings">Writings</a></div></div><div class="mt-2 flex justify-start"><p class="text-base text-foceground-light">My garden is full of bugs, but I&#x27;m loving it!</p></div></div><div class="my-5 w-full mx-auto max-w-2xl px-5"><div class="mt-10 flex justify-between items-center"><p class="text-2xl font-semibold text-foreground">State Machine - The World State</p></div><div class="mt-2 flex justify-start"><p class="text-base text-black-0">The world is run by yesterday, today, and tomorrow. Machines have their states too!</p></div><div class="my-5 border border-dashed border-gray-200"></div><div class="content"><p>Back to the year 2015 when I was learning about Computer Networks at the University. I have decided to write a motion detection application to finish my Network Communication class. The application is simple, I put a motion detection sensor on the table, and if there is any object that moves close to it, it detects and notifies my phone.</p>
<p>I have separated my application into two states idle and working. In the idle state, I simply put my application into an infinity loop where it was listening to events from the motion sensor. Once my application received events from the sensor, it transformed into the working state where it sent a notification to my phone over the internet.</p>
<p>At that time, I didn't have any ideas or a thesis to describe the algorithm I used in my application, I just put it to work as I expected. But now, I can tell you that my application is a simple sample of a state machine application. Today, we will talk more about it - the state machine!</p>
<h1>What is the state machine?</h1>
<p>I really don't like to talk about theory here. In my thought, the state machine is a computer and program architecture where they have states and at a given time, they can work in only one state and only transform to another state when receiving inputs.</p>
<p>Let's talk about my sample application above, It has two states idle and working. It transforms from the idle state to the working state only when it receives events from the sensor and it transforms from the working state to the idle state only when it has already sent notifications to my phone.</p>
<pre><code>                        receives events
+------------------+    from the sensor       +--------------+
|       Idle       | -----------------------> |   Working    |
|                  |                          |              |
| Listening events |                          | Send noties  |
| from the sensor  | &#x3C;----------------------- | to my phone  |
+------------------+     sent notifications   +--------------+
						           
</code></pre>
<h1>In software development</h1>
<p>We are programmers, and we may be familiar with regex expressions of course. To be honest, it was really painful sometimes, but it's really helpful. In regex expressions, we can use a finite state automaton (FSA) - a sub-model of the state machine to recognize if a set of inputs corresponds to an instance of our regular language. For example, we can use FSA to check if a given string, say "<a href="mailto:helloworld@gmail.com">helloworld@gmail.com</a>" is a valid email address or not. If you want to know more about how it works, thanks to Lj Miranda - he wrote a great post to explain it <a href="https://ljvmiranda921.github.io/notebook/2022/10/07/finite-state-automata/">here</a>.</p>
<p>Programming compilers are more complex state machine programs. In the first step, they transform regular source codes by using regex expressions and prepare for the next step - lexical analysis. Lexical analysis takes care of transforming the original source code (that‚Äôs a sequence of characters), into a sequence of substrings (called lexemes), each with its own class (such as keyword, operator, etc.). If you want to know more details about how a compiler works, I recommend you to read this amazing series that was written by Pietro from <a href="https://pgrandinetti.github.io/compilers/">here</a>.</p>
<p>Let's design a program that connects two computers and communicates with each other. We can easily image the program architecture and states as follows:</p>
<ul>
<li>In the beginning, there was no connection, so our program was in an idle state.</li>
<li>When computer A requests to connect with computer B, our program transforms to the connecting state.</li>
<li>When computer B accepts the connection from computer A, our program transforms to the connected state.</li>
<li>When computer A starts to send data to computer B, our program transforms to the sending state.</li>
</ul>
<p>We may need to define more states to fully support the communication of computer A and computer B. Are you familiar with this program? It definitely is the Internet TCP protocol that supports computer communication on the Internet and it is also a state machine.</p>
<h1>In the real world</h1>
<p>Today, we live in a state-machine world where there are a lot of autonomous machines and devices, the perfect example is the vending machine. You can think about it have three states:</p>
<ul>
<li>Idle where it is doing nothing and waiting for you to input your coins.</li>
<li>When it receives your coins, it transforms to the selection state where it is waiting for you to choose what are you buying.</li>
<li>Once you choose your item, it transforms into the release state where it releases your chosen item. After that, it transforms back to the idle state.</li>
</ul>
<p>When we are driving, our car and its machines are being a running state. When we stop the car, they back to the idle state. Of course, we can see a lot of other state machines like ATMs, or washing machines.</p>
<p>By looking at our world itself, it is a state machine as well. Every day, the world receives actions and events from humans, it produces them into results and memories, and transforms into the next state that is called tomorrow. Today is also a state and result of our world's transformation from yesterday. But carefully, the world is one-way state machine that can not be transformed to the previous state. So, pack our memories up and prepare for the next state. ü§™</p>
<h1>Is it the best architecture?</h1>
<p>I can answer to you that it is, and it is not too, dependent on which software we are building, and which context we are using it.</p>
<p>For building autonomous machines, the state machine is the perfect fit architecture. By using a state machine, we completely define our machine's life cycle where we can know exactly what is the state of the machine, what inputs the machine needs, and what the machine does. For instance, let's say the vending machine, we know exactly that the machine only accepts buyer's coins as input, otherwise, it does nothing. And when the machine has coins, we know exactly that the machine will allow buyers to choose their item, no way the machine will do others.</p>
<p>However, let's think about our personal computer, let's say the Macbook. Do we know all states, inputs and what does our Macbook do? I think not. We are using multiple applications on our Macbook at the same time, and every application needs different inputs, does different works, and shows different results. If we break it down into tiny tasks, these tasks also can work with the state machine, but overall, at a given time, our Macbook can not work in the state machine architecture, it must work on multiple tasking architectures.</p>
<h1>We are working with state machine every day</h1>
<p>If you are a front-end developer, have you ever considered your application or website to be a state machine? For example, the website waits for users' input by clicking the button, or inputting some text and the website starts to do some actions like validate inputs, or call API data, ... If you are working with some framework like React, or Redux, you really know what a state is. Krasimir Tsonev wrote an excellent article to describe how he thinks of state machine as a front-end developer <a href="https://www.smashingmagazine.com/2018/01/rise-state-machines/">here</a>.</p>
<p>As a data engineer, I think you already know exactly the importance of a state machine. Our database is a state at a given time, and it can be transformed to other states by doing some data manipulation transactions. At every state of the database, our data have specific relationships with others and we can completely revert the entry database into a specific state when we need to.</p>
<p>Maybe I don't need to talk about a state machine with embedded developers, they all know what it is, even they slept with it every night. Embedded developers create autonomous machines, and write automation codes every day, and they are all about state machines.</p>
<h1>Many thanks to</h1>
<ul>
<li><a href="https://ljvmiranda921.github.io/notebook/2022/10/07/finite-state-automata/">Lj Miranda</a> for writing a great article to explain how regex expressions work.</li>
<li><a href="https://pgrandinetti.github.io/compilers/">Pietro Grandinetti</a> for writing a amazing series about compilers.</li>
<li><a href="https://www.smashingmagazine.com/2018/01/rise-state-machines/">Krasimir Tsonev</a> for writing an excellent article to describe how he thinks of state machine as a front-end developer.</li>
</ul></div><!--$--><!--/$--></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"state-machine-the-world-state","contentHtml":"\u003cp\u003eBack to the year 2015 when I was learning about Computer Networks at the University. I have decided to write a motion detection application to finish my Network Communication class. The application is simple, I put a motion detection sensor on the table, and if there is any object that moves close to it, it detects and notifies my phone.\u003c/p\u003e\n\u003cp\u003eI have separated my application into two states idle and working. In the idle state, I simply put my application into an infinity loop where it was listening to events from the motion sensor. Once my application received events from the sensor, it transformed into the working state where it sent a notification to my phone over the internet.\u003c/p\u003e\n\u003cp\u003eAt that time, I didn't have any ideas or a thesis to describe the algorithm I used in my application, I just put it to work as I expected. But now, I can tell you that my application is a simple sample of a state machine application. Today, we will talk more about it - the state machine!\u003c/p\u003e\n\u003ch1\u003eWhat is the state machine?\u003c/h1\u003e\n\u003cp\u003eI really don't like to talk about theory here. In my thought, the state machine is a computer and program architecture where they have states and at a given time, they can work in only one state and only transform to another state when receiving inputs.\u003c/p\u003e\n\u003cp\u003eLet's talk about my sample application above, It has two states idle and working. It transforms from the idle state to the working state only when it receives events from the sensor and it transforms from the working state to the idle state only when it has already sent notifications to my phone.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                        receives events\n+------------------+    from the sensor       +--------------+\n|       Idle       | -----------------------\u003e |   Working    |\n|                  |                          |              |\n| Listening events |                          | Send noties  |\n| from the sensor  | \u0026#x3C;----------------------- | to my phone  |\n+------------------+     sent notifications   +--------------+\n\t\t\t\t\t\t           \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eIn software development\u003c/h1\u003e\n\u003cp\u003eWe are programmers, and we may be familiar with regex expressions of course. To be honest, it was really painful sometimes, but it's really helpful. In regex expressions, we can use a finite state automaton (FSA) - a sub-model of the state machine to recognize if a set of inputs corresponds to an instance of our regular language. For example, we can use FSA to check if a given string, say \"\u003ca href=\"mailto:helloworld@gmail.com\"\u003ehelloworld@gmail.com\u003c/a\u003e\" is a valid email address or not. If you want to know more about how it works, thanks to Lj Miranda - he wrote a great post to explain it \u003ca href=\"https://ljvmiranda921.github.io/notebook/2022/10/07/finite-state-automata/\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eProgramming compilers are more complex state machine programs. In the first step, they transform regular source codes by using regex expressions and prepare for the next step - lexical analysis. Lexical analysis takes care of transforming the original source code (that‚Äôs a sequence of characters), into a sequence of substrings (called lexemes), each with its own class (such as keyword, operator, etc.). If you want to know more details about how a compiler works, I recommend you to read this amazing series that was written by Pietro from \u003ca href=\"https://pgrandinetti.github.io/compilers/\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eLet's design a program that connects two computers and communicates with each other. We can easily image the program architecture and states as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIn the beginning, there was no connection, so our program was in an idle state.\u003c/li\u003e\n\u003cli\u003eWhen computer A requests to connect with computer B, our program transforms to the connecting state.\u003c/li\u003e\n\u003cli\u003eWhen computer B accepts the connection from computer A, our program transforms to the connected state.\u003c/li\u003e\n\u003cli\u003eWhen computer A starts to send data to computer B, our program transforms to the sending state.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe may need to define more states to fully support the communication of computer A and computer B. Are you familiar with this program? It definitely is the Internet TCP protocol that supports computer communication on the Internet and it is also a state machine.\u003c/p\u003e\n\u003ch1\u003eIn the real world\u003c/h1\u003e\n\u003cp\u003eToday, we live in a state-machine world where there are a lot of autonomous machines and devices, the perfect example is the vending machine. You can think about it have three states:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIdle where it is doing nothing and waiting for you to input your coins.\u003c/li\u003e\n\u003cli\u003eWhen it receives your coins, it transforms to the selection state where it is waiting for you to choose what are you buying.\u003c/li\u003e\n\u003cli\u003eOnce you choose your item, it transforms into the release state where it releases your chosen item. After that, it transforms back to the idle state.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen we are driving, our car and its machines are being a running state. When we stop the car, they back to the idle state. Of course, we can see a lot of other state machines like ATMs, or washing machines.\u003c/p\u003e\n\u003cp\u003eBy looking at our world itself, it is a state machine as well. Every day, the world receives actions and events from humans, it produces them into results and memories, and transforms into the next state that is called tomorrow. Today is also a state and result of our world's transformation from yesterday. But carefully, the world is one-way state machine that can not be transformed to the previous state. So, pack our memories up and prepare for the next state. ü§™\u003c/p\u003e\n\u003ch1\u003eIs it the best architecture?\u003c/h1\u003e\n\u003cp\u003eI can answer to you that it is, and it is not too, dependent on which software we are building, and which context we are using it.\u003c/p\u003e\n\u003cp\u003eFor building autonomous machines, the state machine is the perfect fit architecture. By using a state machine, we completely define our machine's life cycle where we can know exactly what is the state of the machine, what inputs the machine needs, and what the machine does. For instance, let's say the vending machine, we know exactly that the machine only accepts buyer's coins as input, otherwise, it does nothing. And when the machine has coins, we know exactly that the machine will allow buyers to choose their item, no way the machine will do others.\u003c/p\u003e\n\u003cp\u003eHowever, let's think about our personal computer, let's say the Macbook. Do we know all states, inputs and what does our Macbook do? I think not. We are using multiple applications on our Macbook at the same time, and every application needs different inputs, does different works, and shows different results. If we break it down into tiny tasks, these tasks also can work with the state machine, but overall, at a given time, our Macbook can not work in the state machine architecture, it must work on multiple tasking architectures.\u003c/p\u003e\n\u003ch1\u003eWe are working with state machine every day\u003c/h1\u003e\n\u003cp\u003eIf you are a front-end developer, have you ever considered your application or website to be a state machine? For example, the website waits for users' input by clicking the button, or inputting some text and the website starts to do some actions like validate inputs, or call API data, ... If you are working with some framework like React, or Redux, you really know what a state is. Krasimir Tsonev wrote an excellent article to describe how he thinks of state machine as a front-end developer \u003ca href=\"https://www.smashingmagazine.com/2018/01/rise-state-machines/\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAs a data engineer, I think you already know exactly the importance of a state machine. Our database is a state at a given time, and it can be transformed to other states by doing some data manipulation transactions. At every state of the database, our data have specific relationships with others and we can completely revert the entry database into a specific state when we need to.\u003c/p\u003e\n\u003cp\u003eMaybe I don't need to talk about a state machine with embedded developers, they all know what it is, even they slept with it every night. Embedded developers create autonomous machines, and write automation codes every day, and they are all about state machines.\u003c/p\u003e\n\u003ch1\u003eMany thanks to\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ljvmiranda921.github.io/notebook/2022/10/07/finite-state-automata/\"\u003eLj Miranda\u003c/a\u003e for writing a great article to explain how regex expressions work.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pgrandinetti.github.io/compilers/\"\u003ePietro Grandinetti\u003c/a\u003e for writing a amazing series about compilers.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.smashingmagazine.com/2018/01/rise-state-machines/\"\u003eKrasimir Tsonev\u003c/a\u003e for writing an excellent article to describe how he thinks of state machine as a front-end developer.\u003c/li\u003e\n\u003c/ul\u003e","title":"State Machine - The World State","description":"The world is run by yesterday, today, and tomorrow. Machines have their states too!","author":"Eden","date":"Apr 1st, 2022","tag":"Writing"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"state-machine-the-world-state"},"buildId":"Zqp_tgPZRVjTdyHmPCy7k","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>