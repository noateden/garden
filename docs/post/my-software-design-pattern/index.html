<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/9dd713fd4ffd7d87.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9dd713fd4ffd7d87.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/_next/static/chunks/main-805fb4f55afd8b07.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e7e2a935ab64e067.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-f60aef3f2a9870a4.js" defer=""></script><script src="/_next/static/bvWs7m9VIjVeYd0LBXRGq/_buildManifest.js" defer=""></script><script src="/_next/static/bvWs7m9VIjVeYd0LBXRGq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="__className_01316c"><div class="mx-auto max-w-2xl px-5"><div class="mt-10 flex justify-between items-center"><a href="/"><p class="text-xl font-bold text-foreground">Eden Garden üçÉ</p></a><div class="flex justify-center"><a class="underline" href="/">Home</a><a class="ml-5 underline" href="/writings">Writings</a></div></div><div class="mt-2 flex justify-start"><p class="text-base text-foceground-light">My garden is full of bugs, but I&#x27;m loving it!</p></div></div><div class="my-5 w-full mx-auto max-w-2xl px-5"><div class="mt-10 flex justify-between items-center"><p class="text-2xl font-semibold text-foreground">My Software Design Pattern</p></div><div class="mt-2 flex justify-start"><p class="text-base text-black-0">Let me share with you my favorite pattern and structure I usually use in my codebases.</p></div><div class="my-5 border border-dashed border-gray-200"></div><div class="content"><p>The software design pattern is essential when we start to develop software.
It's about how we structure our codes, how we split our codes into components and modules, what framework we are going to use, etc.
There are a lot of books that have a lot of great patterns we can follow.
However, as a developer, I believe that every one of us has a pattern for ourselves and we like to use it.</p>
<p>My design came from many projects and code bases I have worked with.
From codebases for an embedded device to a web service, I have established a common pattern for all of them.</p>
<h1>The entrypoint should be commands</h1>
<p>The final executable file or entry point should support multiple commands and options to do all functions of the software.
For example, let's say a tool that imports and exports a database, it has simple two main functions.
If it was me 4 years ago, I will output two executable files including import and export and I will use this tool as below:</p>
<pre><code class="language-bash"># use tool_import when I need to import database
tool_import some_database

# use tool_export when I need to export database
tool_export some_database
</code></pre>
<p>But I'm at present, I will output only an executable file and use it as below:</p>
<pre><code class="language-bash"># use tool with import command and options
tool import --database some_database --from ./some_databse.backup

# use tool with export command and options
tool export --database some_database --to ./some_databse.backup
</code></pre>
<p>Good things from the second design are:</p>
<ul>
<li>It's easy to add more functions and options (easy to scale).</li>
<li>It's easy to know what does the tool do (use the help command).</li>
</ul>
<h1>Put reusable codes into libraries</h1>
<p>Many codebases sometime use the same codes and utility functions.
For example, convert time formats, read file content, or print logs in our favorite format.
And I put these pieces of code into separate libraries, then export them, so I can easily import them into other codebases.</p>
<p>The best thing about this design is I can reuse my codes in multiple codebases, prevent duplicated codes, and save time.</p>
<h1>Split external integrations into services</h1>
<p>Our software doesn't do everything itself, also integrates with other software as well. I usually write services that do tasks and calls to a specific service.
For example, if my software needs a database, I will build up a service that handles all logic and calls to the database service. I usually name it a database service or storage service.
And with every external software like that, I also write another service too.</p>
<p>This design brings to me some good things:</p>
<ul>
<li>It's easy to update or integrate with external services. For example, when we need to update the database library, we just need to update codes in the database service and do tests with it only without retest with the whole codebase.</li>
<li>It helps me also reuse the codes in multiple codebases.</li>
</ul>
<p>Furthermore, I usually design my service with the inheritance.
Whenever I need to read from or write to the database, I need to request the database service only.
And on behalf of my call, the database service should be able to handle requests to Postgresql, MongoDB, or whatever database I'm using.
It makes me easy to scale up whenever I need to integrate with another service.</p>
<pre><code class="language-text">
+-----------------+                             +---------------+
|    Somewhere    |  request to read database   |    Database   |
|    in my code   | --------------------------> |    service    |
+-----------------+                             +---------------+
                                                        |
                                +---------------+---------------+
                                |               |               |
                                |               |               |
                         +--------------+  +------------+   +------------+
                         | Easy to      |  | Postgresql |   | MongoDB    |
                         | add more ... |  |            |   |            |
                         +--------------+  +------------+   +------------+
</code></pre>
<h1>Write main logic in modules</h1>
<p>I usually split my software logic into multiple modules, every module does a specific function.
For example, in an e-commerce API service, I will split logic into basic modules as below:</p>
<ul>
<li>API routes, initialize web router and API routing.</li>
<li>Account, handle all logic related to accounts like create, update, login, ...</li>
<li>Payment, handle all logic about payment, charges, subscriptions, ...</li>
</ul>
<p>In every module, it can call external services or use utility libraries following my design above.</p>
<p>By split logic into modules, I can:</p>
<ul>
<li>Easy to scale my software, when I need to add more functions, I just need to make another module.</li>
<li>Easy to do tests with software logic in modules one by one.</li>
</ul>
<pre><code class="language-text">
+-----------------+                        +--------------+
|    Account      |   save account data    |   Database   |
|    module       | ---------------------> |   service    |
+-----------------+   |                    +--------------+
       |              |
       |              | write logs         +--------------+
       |              |------------------> |  Logging     |
+-----------------+                        |  service     |
|  Validation     |                        +--------------|
|  library        |
+-----------------+
</code></pre>
<h1>Configurations</h1>
<p>My favorite config format is <code>.env</code> files, or I just directly export them to environment variables.
I don't really have many reasons for this, but I think because I usually deploy my code using Docker or cloud services like Heroku.
So, environment variables are easy to use with these platforms.</p>
<h1>Codebase files structure</h1>
<p>As my design, I structure my codebase folders into four main directories:</p>
<pre><code class="language-text">
/
|--cmd          // contains all export commands, and entry points
|--lib,         // contains all external libraries, or utility functions
|--modules,     // contains all external service integration logic
|--services,    // contains the software logic

</code></pre>
<p>This pattern is just my personal favorite, of course, I don't use it in every software I built, but it is the most pattern I have ever used. Happy building!</p></div><!--$--><!--/$--></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"my-software-design-pattern","contentHtml":"\u003cp\u003eThe software design pattern is essential when we start to develop software.\nIt's about how we structure our codes, how we split our codes into components and modules, what framework we are going to use, etc.\nThere are a lot of books that have a lot of great patterns we can follow.\nHowever, as a developer, I believe that every one of us has a pattern for ourselves and we like to use it.\u003c/p\u003e\n\u003cp\u003eMy design came from many projects and code bases I have worked with.\nFrom codebases for an embedded device to a web service, I have established a common pattern for all of them.\u003c/p\u003e\n\u003ch1\u003eThe entrypoint should be commands\u003c/h1\u003e\n\u003cp\u003eThe final executable file or entry point should support multiple commands and options to do all functions of the software.\nFor example, let's say a tool that imports and exports a database, it has simple two main functions.\nIf it was me 4 years ago, I will output two executable files including import and export and I will use this tool as below:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# use tool_import when I need to import database\ntool_import some_database\n\n# use tool_export when I need to export database\ntool_export some_database\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut I'm at present, I will output only an executable file and use it as below:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# use tool with import command and options\ntool import --database some_database --from ./some_databse.backup\n\n# use tool with export command and options\ntool export --database some_database --to ./some_databse.backup\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGood things from the second design are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt's easy to add more functions and options (easy to scale).\u003c/li\u003e\n\u003cli\u003eIt's easy to know what does the tool do (use the help command).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003ePut reusable codes into libraries\u003c/h1\u003e\n\u003cp\u003eMany codebases sometime use the same codes and utility functions.\nFor example, convert time formats, read file content, or print logs in our favorite format.\nAnd I put these pieces of code into separate libraries, then export them, so I can easily import them into other codebases.\u003c/p\u003e\n\u003cp\u003eThe best thing about this design is I can reuse my codes in multiple codebases, prevent duplicated codes, and save time.\u003c/p\u003e\n\u003ch1\u003eSplit external integrations into services\u003c/h1\u003e\n\u003cp\u003eOur software doesn't do everything itself, also integrates with other software as well. I usually write services that do tasks and calls to a specific service.\nFor example, if my software needs a database, I will build up a service that handles all logic and calls to the database service. I usually name it a database service or storage service.\nAnd with every external software like that, I also write another service too.\u003c/p\u003e\n\u003cp\u003eThis design brings to me some good things:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt's easy to update or integrate with external services. For example, when we need to update the database library, we just need to update codes in the database service and do tests with it only without retest with the whole codebase.\u003c/li\u003e\n\u003cli\u003eIt helps me also reuse the codes in multiple codebases.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, I usually design my service with the inheritance.\nWhenever I need to read from or write to the database, I need to request the database service only.\nAnd on behalf of my call, the database service should be able to handle requests to Postgresql, MongoDB, or whatever database I'm using.\nIt makes me easy to scale up whenever I need to integrate with another service.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e\n+-----------------+                             +---------------+\n|    Somewhere    |  request to read database   |    Database   |\n|    in my code   | --------------------------\u003e |    service    |\n+-----------------+                             +---------------+\n                                                        |\n                                +---------------+---------------+\n                                |               |               |\n                                |               |               |\n                         +--------------+  +------------+   +------------+\n                         | Easy to      |  | Postgresql |   | MongoDB    |\n                         | add more ... |  |            |   |            |\n                         +--------------+  +------------+   +------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eWrite main logic in modules\u003c/h1\u003e\n\u003cp\u003eI usually split my software logic into multiple modules, every module does a specific function.\nFor example, in an e-commerce API service, I will split logic into basic modules as below:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAPI routes, initialize web router and API routing.\u003c/li\u003e\n\u003cli\u003eAccount, handle all logic related to accounts like create, update, login, ...\u003c/li\u003e\n\u003cli\u003ePayment, handle all logic about payment, charges, subscriptions, ...\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn every module, it can call external services or use utility libraries following my design above.\u003c/p\u003e\n\u003cp\u003eBy split logic into modules, I can:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEasy to scale my software, when I need to add more functions, I just need to make another module.\u003c/li\u003e\n\u003cli\u003eEasy to do tests with software logic in modules one by one.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e\n+-----------------+                        +--------------+\n|    Account      |   save account data    |   Database   |\n|    module       | ---------------------\u003e |   service    |\n+-----------------+   |                    +--------------+\n       |              |\n       |              | write logs         +--------------+\n       |              |------------------\u003e |  Logging     |\n+-----------------+                        |  service     |\n|  Validation     |                        +--------------|\n|  library        |\n+-----------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eConfigurations\u003c/h1\u003e\n\u003cp\u003eMy favorite config format is \u003ccode\u003e.env\u003c/code\u003e files, or I just directly export them to environment variables.\nI don't really have many reasons for this, but I think because I usually deploy my code using Docker or cloud services like Heroku.\nSo, environment variables are easy to use with these platforms.\u003c/p\u003e\n\u003ch1\u003eCodebase files structure\u003c/h1\u003e\n\u003cp\u003eAs my design, I structure my codebase folders into four main directories:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e\n/\n|--cmd          // contains all export commands, and entry points\n|--lib,         // contains all external libraries, or utility functions\n|--modules,     // contains all external service integration logic\n|--services,    // contains the software logic\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis pattern is just my personal favorite, of course, I don't use it in every software I built, but it is the most pattern I have ever used. Happy building!\u003c/p\u003e","title":"My Software Design Pattern","description":"Let me share with you my favorite pattern and structure I usually use in my codebases.","author":"Eden","date":"Oct 1st, 2021","tag":"Writing"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"my-software-design-pattern"},"buildId":"bvWs7m9VIjVeYd0LBXRGq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>